class EphemeralConfig{constructor(object,path){const self=this;this.object=object,this.path=path,this.object&&Object.assign(self,this.object)}get(path,defaultValue){if(void 0!==this.object?.[path])return this.object?.[path];const pathSteps=path?.split(".")||[];let root=this.object;for(let i=0;i<pathSteps.length&&null!=root;i++)root=root?.[pathSteps[i]];if(root)return root;if(void 0!==defaultValue)return defaultValue;throw new Error(`Config path ${path} returned no value.`)}has(path){if(void 0!==this.object?.[path])return!0;const pathSteps=path?.split(".")||[];let root=this.object;for(let i=0;i<pathSteps.length&&null!=root;i++)root=root?.[pathSteps[i]];return null!=root}}class DelegatingConfig{static getTag(value){return null==value?void 0===value?"[object Undefined]":"[object Null]":toString.call(value)}static isObjectLike(value){return"object"==typeof value&&null!==value}static isPlainObject(value){if(!DelegatingConfig.isObjectLike(value)||"[object Object]"!==DelegatingConfig.getTag(value))return!1;if(null===Object.getPrototypeOf(value))return!0;let proto=value;for(;null!==Object.getPrototypeOf(proto);)proto=Object.getPrototypeOf(proto);return Object.getPrototypeOf(value)===proto}constructor(config,path){DelegatingConfig.isPlainObject(config)?this.config=new EphemeralConfig(config):this.config=config;const originalConfig=this.config;Object.assign(this,config),this.config=originalConfig,this.path=path}has(path){return this.config.has(path)}}class Resolver{static isObject(value){const type=typeof value;return null!=value&&("object"===type||"function"===type)}mapValuesDeep(values,callback){return Resolver.isObject(values)?Object.fromEntries(Object.entries(values).map((([key,value])=>[key,this.mapValuesDeep(value,callback)]))):callback(values)}async asyncMapValuesDeep(values,callback){return Resolver.isObject(values)?Object.fromEntries(Object.entries(values).map((async([key,value])=>[key,this.mapValuesDeep(value,callback)]))):callback(values)}}class DelegatingResolver extends Resolver{constructor(resolvers){super(),this.resolvers=resolvers}resolve(config){let resolvedConfig=config;for(let i=0;i<this.resolvers.length;i++)resolvedConfig=this.resolvers[i].resolve(resolvedConfig);return resolvedConfig}}class SelectiveResolver extends Resolver{constructor(selector){super(),this.selector=selector}}class Selector{}class PlaceHolderSelector extends Selector{matches(value){return"string"==typeof value&&value.includes("${")&&value.includes("}")&&value.indexOf("${")<value.indexOf("}")}}class PlaceHolderResolver extends SelectiveResolver{constructor(selector,reference){super(selector||new PlaceHolderSelector),this.reference=reference}resolve(config){const self=this;return Resolver.prototype.mapValuesDeep(config,(v=>{if(self.selector.matches(v))try{let placeholder,resolvedValue="",remainder=v;for(;""===resolvedValue||remainder.includes("${")&&remainder.includes("}")&&remainder.indexOf("${")<remainder.indexOf("}");)resolvedValue=`${resolvedValue}${remainder.substring(0,remainder.indexOf("${"))}`,placeholder=remainder.substring(remainder.indexOf("${")+2,remainder.indexOf("}")),resolvedValue=`${resolvedValue}${self.reference.get(placeholder)}`,remainder=remainder.substring(remainder.indexOf("}")+1);return resolvedValue=`${resolvedValue}${remainder}`,resolvedValue}catch(e){return v}return v}))}}class PrefixSelector extends Selector{constructor(prefix){super(),this.prefix=prefix}matches(value){return"string"==typeof value&&value.startsWith(this.prefix)}resolveValue(value){return value.replaceAll(this.prefix,"")}async asyncResolveValue(value){return this.resolveValue(value)}}class URLResolver extends SelectiveResolver{constructor(selector,fetchArg){super(selector||new PrefixSelector("url.")),this.$fetch=fetchArg}resolve(config){const self=this;return Resolver.prototype.mapValuesDeep(config,(v=>{if(self.selector.matches(v))try{return v}catch(e){return v}return v}))}async asyncResolve(config,parentConfig,path){const self=this;return await Resolver.prototype.asyncMapValuesDeep(config,(async v=>{if(self.selector.matches(v))try{const selectedValue=self.selector.resolveValue(v),urlPath=path.substring(0,path.lastIndexOf(".")),method=parentConfig.has(`${urlPath}.method`)?parentConfig.get(`${urlPath}.method`):null,authorization=parentConfig.has(`${urlPath}.authorization`)?parentConfig.get(`${urlPath}.authorization`):null,body=parentConfig.has(`${urlPath}.body`)?parentConfig.get(`${urlPath}.body`):null,headers=parentConfig.has(`${urlPath}.headers`)?parentConfig.get(`${urlPath}.headers`):null;return await this.fetch(selectedValue,authorization,method,body,headers)}catch(e){return v}return v}))}async fetch(url,authorization,method,body,headers){if(!this.$fetch)throw new Error("fetch is required");const $headers=authorization?{authorization:authorization}:{};Object.assign($headers,headers);const opts={method:method||"get",headers:$headers};return method&&"get"!==method?.toLowerCase()&&"head"!==method?.toLowerCase()&&Object.assign(opts,JSON.stringify(body||{})),this.$fetch(url,opts).then((res=>res.json()))}}class ValueResolvingConfig extends DelegatingConfig{constructor(config,resolver,path,async){super(config,path);const self=this;this.resolver=resolver,this.config&&!async&&(this.resolved_config=resolver.resolve(null==this.path?config:this.config.get(path)),Object.assign(self,this.resolved_config)),ValueResolvingConfig.prototype.has=DelegatingConfig.prototype.has}get(path,defaultValue){return void 0!==defaultValue&&!1===this.has(path)?defaultValue:new ValueResolvingConfig(this.config,this.resolver,path).resolved_config}async fetch(path,defaultValue){if(defaultValue&&!1===this.has(path))return defaultValue;const asyncConfig=new ValueResolvingConfig(this.config,this.resolver,path,!0);return asyncConfig.resolver.asyncResolve(null==asyncConfig.path?asyncConfig:asyncConfig.config.get(asyncConfig.path),this,path)}}class WindowLocationConfig extends DelegatingConfig{constructor(config,path){super(config,path)}has(path){const location=`${window.location.origin}${window.location.pathname}`.replaceAll(".","+");return this.config.has(`${location}.${path}`)||this.config.has(path)}get(path,defaultValue){const location=`${window.location.origin}${window.location.pathname}`.replaceAll(".","+");return void 0!==defaultValue&&!1===this.has(path)?defaultValue:this.config.has(`${location}.${path}`)?this.config.get(`${location}.${path}`):this.config.get(path)}}class ConfigFactory{static getGlobalRef(){let $globalref=null;return $globalref=ConfigFactory.detectBrowser()?window:global,$globalref}static getGlobalRoot(key){const $globalref=ConfigFactory.getGlobalRef();let $key=$globalref&&$globalref.boot;return $key=$key&&$key.contexts,$key=$key&&$key.root,$key=$key&&$key[`${key}`],$key}static detectBrowser(){return!("undefined"==typeof window)}static detectFetch(fetchArg){let $fetch=null;return"undefined"!=typeof fetch&&($fetch=fetch),ConfigFactory.getGlobalRoot("fetch")&&($fetch=ConfigFactory.getGlobalRoot("fetch")),$fetch=fetchArg||$fetch,$fetch}static getConfig(config,resolver,fetchArg){const placeHolderResolver=new PlaceHolderResolver(new PlaceHolderSelector),urlResolver=new URLResolver(new PrefixSelector("url."),ConfigFactory.detectFetch(fetchArg)),delegatingResolver=new DelegatingResolver([placeHolderResolver,urlResolver]),valueResolvingConfig=new ValueResolvingConfig(config,resolver||delegatingResolver);placeHolderResolver.reference=valueResolvingConfig;return new WindowLocationConfig(valueResolvingConfig)}}export{ConfigFactory,DelegatingConfig,DelegatingResolver,EphemeralConfig,PlaceHolderResolver,PlaceHolderSelector,PrefixSelector,Resolver,SelectiveResolver,Selector,URLResolver,ValueResolvingConfig};